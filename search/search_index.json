{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyCLI MCP","text":"CI/CD Docs Package Meta <p>This provides an extensible MCP server that is compatible with any Python command line application.</p> <p>Supported frameworks:</p> <ul> <li>Click</li> <li>Typer</li> <li>Argparse (experimental support)</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<p>Desktop readers can use keyboard shortcuts to navigate.</p> Keys Action <ul><li>, (comma)</li><li>p</li></ul> Navigate to the \"previous\" page <ul><li>. (period)</li><li>n</li></ul> Navigate to the \"next\" page <ul><li>/</li><li>s</li></ul> Display the search modal"},{"location":"api/","title":"API reference","text":""},{"location":"api/#pycli_mcp.server.CommandMCPServer","title":"CommandMCPServer","text":"<p>An MCP server that can be used to run Python CLIs, backed by Starlette and Uvicorn. Example usage:</p> <pre><code>from pycli_mcp import CommandMCPServer\n\nfrom mypkg.cli import cmd\n\nserver = CommandMCPServer(commands=[cmd], stateless=True)\nserver.run()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Sequence[Any]</code> <p>The commands to expose as MCP tools.</p> required <p>Other Parameters:</p> Name Type Description <code>event_store</code> <code>EventStore | None</code> <p>Optional event store that allows clients to reconnect and receive missed events. If <code>None</code>, sessions are still tracked but not resumable.</p> <code>stateless</code> <code>bool</code> <p>Whether to create a completely fresh transport for each request with no session tracking or state persistence between requests.</p> <code>**app_settings</code> <code>Any</code> <p>Additional settings to pass to the Starlette application.</p> Source code in <code>src/pycli_mcp/server.py</code> <pre><code>class CommandMCPServer:\n    \"\"\"\n    An MCP server that can be used to run Python CLIs, backed by [Starlette](https://github.com/encode/starlette)\n    and [Uvicorn](https://github.com/encode/uvicorn). Example usage:\n\n    ```python\n    from pycli_mcp import CommandMCPServer\n\n    from mypkg.cli import cmd\n\n    server = CommandMCPServer(commands=[cmd], stateless=True)\n    server.run()\n    ```\n\n    Parameters:\n        commands: The commands to expose as MCP tools.\n\n    Other parameters:\n        event_store: Optional [event store](https://github.com/modelcontextprotocol/python-sdk/blob/v1.9.4/src/mcp/server/streamable_http.py#L79)\n            that allows clients to reconnect and receive missed events. If `None`, sessions are still tracked but not\n            resumable.\n        stateless: Whether to create a completely fresh transport for each request with no session tracking or state\n            persistence between requests.\n        **app_settings: Additional settings to pass to the Starlette [application][starlette.applications.Starlette].\n    \"\"\"\n\n    def __init__(\n        self,\n        commands: Sequence[Any],\n        *,\n        event_store: EventStore | None = None,\n        stateless: bool = False,\n        **app_settings: Any,\n    ) -&gt; None:\n        self.__command_queries = [c if isinstance(c, CommandQuery) else CommandQuery(c) for c in commands]\n        self.__app_settings = app_settings\n        self.__server: Server = Server(\"pycli_mcp\")\n        self.__session_manager = StreamableHTTPSessionManager(\n            app=self.__server,\n            event_store=event_store,\n            stateless=stateless,\n            json_response=True,\n        )\n\n        # Register handlers\n        self.__server.request_handlers[ListToolsRequest] = self.list_tools_handler\n        self.__server.request_handlers[CallToolRequest] = self.call_tool_handler\n\n    @property\n    def server(self) -&gt; Server:\n        \"\"\"\n        Returns:\n            The underlying [low-level server](https://github.com/modelcontextprotocol/python-sdk/blob/v1.9.4/src/mcp/server/lowlevel/server.py)\n                instance. You can use this to register additional handlers.\n        \"\"\"\n        return self.__server\n\n    @property\n    def session_manager(self) -&gt; StreamableHTTPSessionManager:\n        \"\"\"\n        Returns:\n            The underlying [session manager](https://github.com/modelcontextprotocol/python-sdk/blob/v1.9.4/src/mcp/server/streamable_http_manager.py#L29)\n                instance. You only need to use this if you want to override the `lifetime` context manager\n        \"\"\"\n        return self.__session_manager\n\n    @cached_property\n    def commands(self) -&gt; dict[str, Command]:\n        \"\"\"\n        Returns:\n            Dictionary used internally to store metadata about the exposed commands. Although it should not be modified,\n                the keys are the available MCP tool names and useful to know when overriding the default handlers.\n        \"\"\"\n        commands: dict[str, Command] = {}\n        for query in self.__command_queries:\n            for metadata in query:\n                tool_name = metadata.path.replace(\" \", \".\").replace(\"-\", \"_\")\n                tool = Tool(\n                    name=tool_name,\n                    description=metadata.schema[\"description\"],\n                    inputSchema=metadata.schema,\n                )\n                commands[tool_name] = Command(metadata, tool)\n\n        return commands\n\n    @cached_property\n    def routes(self) -&gt; list[Mount]:\n        \"\"\"\n        This would only be used directly if you want to add more routes in addition to the default `/mcp` route.\n\n        Returns:\n            The [routes](https://www.starlette.io/routing/#http-routing) to mount in the Starlette\n                [application][starlette.applications.Starlette].\n        \"\"\"\n        return [Mount(\"/mcp\", app=self.session_manager.handle_request)]\n\n    @asynccontextmanager\n    async def lifespan(self, app: Starlette) -&gt; AsyncIterator[None]:  # noqa: ARG002\n        \"\"\"\n        The default lifespan context manager used by the Starlette [application][starlette.applications.Starlette].\n        \"\"\"\n        async with self.session_manager.run():\n            yield\n\n    def list_command_tools(self) -&gt; list[Tool]:\n        \"\"\"\n        This would only be used directly if you want to override the handler for the `ListToolsRequest`.\n\n        Returns:\n            The MCP tools for the commands.\n        \"\"\"\n        return [command.tool for command in self.commands.values()]\n\n    async def list_tools_handler(self, _: ListToolsRequest) -&gt; ServerResult:\n        \"\"\"\n        The default handler for the `ListToolsRequest`.\n        \"\"\"\n        return ServerResult(ListToolsResult(tools=self.list_command_tools()))\n\n    async def call_tool_handler(self, req: CallToolRequest) -&gt; ServerResult:\n        \"\"\"\n        The default handler for the `CallToolRequest`.\n        \"\"\"\n        command = self.commands[req.params.name].metadata.construct(req.params.arguments)\n        env_vars = dict(os.environ)\n        env_vars[\"PYCLI_MCP_TOOL_NAME\"] = req.params.name\n\n        try:\n            process = subprocess.run(  # noqa: PLW1510\n                command,\n                encoding=\"utf-8\",\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                env=env_vars,\n            )\n        # This can happen if the command is not found\n        except subprocess.CalledProcessError as e:\n            return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=str(e))], isError=True))\n\n        if process.returncode:\n            msg = f\"{process.stdout}\\nThis command exited with non-zero exit code `{process.returncode}`: {command}\"\n            return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=msg)], isError=True))\n\n        return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=process.stdout)]))\n\n    def run(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Other parameters:\n            **kwargs: Additional settings to pass to the [`uvicorn.run`](https://www.uvicorn.org/#uvicornrun) function.\n        \"\"\"\n        app_settings = self.__app_settings.copy()\n        app_settings[\"routes\"] = self.routes\n        app_settings.setdefault(\"lifespan\", self.lifespan)\n        app = Starlette(**app_settings)\n        uvicorn.run(app, **kwargs)\n</code></pre>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.server","title":"server","text":"<pre><code>server: Server\n</code></pre> <p>Returns:</p> Type Description <code>Server</code> <p>The underlying low-level server instance. You can use this to register additional handlers.</p>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.session_manager","title":"session_manager","text":"<pre><code>session_manager: StreamableHTTPSessionManager\n</code></pre> <p>Returns:</p> Type Description <code>StreamableHTTPSessionManager</code> <p>The underlying session manager instance. You only need to use this if you want to override the <code>lifetime</code> context manager</p>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.commands","title":"commands","text":"<pre><code>commands: dict[str, Command]\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, Command]</code> <p>Dictionary used internally to store metadata about the exposed commands. Although it should not be modified, the keys are the available MCP tool names and useful to know when overriding the default handlers.</p>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.routes","title":"routes","text":"<pre><code>routes: list[Mount]\n</code></pre> <p>This would only be used directly if you want to add more routes in addition to the default <code>/mcp</code> route.</p> <p>Returns:</p> Type Description <code>list[Mount]</code> <p>The routes to mount in the Starlette application.</p>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.lifespan","title":"lifespan","text":"<pre><code>lifespan(app: Starlette) -&gt; AsyncIterator[None]\n</code></pre> <p>The default lifespan context manager used by the Starlette application.</p> Source code in <code>src/pycli_mcp/server.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: Starlette) -&gt; AsyncIterator[None]:  # noqa: ARG002\n    \"\"\"\n    The default lifespan context manager used by the Starlette [application][starlette.applications.Starlette].\n    \"\"\"\n    async with self.session_manager.run():\n        yield\n</code></pre>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.list_command_tools","title":"list_command_tools","text":"<pre><code>list_command_tools() -&gt; list[Tool]\n</code></pre> <p>This would only be used directly if you want to override the handler for the <code>ListToolsRequest</code>.</p> <p>Returns:</p> Type Description <code>list[Tool]</code> <p>The MCP tools for the commands.</p> Source code in <code>src/pycli_mcp/server.py</code> <pre><code>def list_command_tools(self) -&gt; list[Tool]:\n    \"\"\"\n    This would only be used directly if you want to override the handler for the `ListToolsRequest`.\n\n    Returns:\n        The MCP tools for the commands.\n    \"\"\"\n    return [command.tool for command in self.commands.values()]\n</code></pre>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.list_tools_handler","title":"list_tools_handler","text":"<pre><code>list_tools_handler(_: ListToolsRequest) -&gt; ServerResult\n</code></pre> <p>The default handler for the <code>ListToolsRequest</code>.</p> Source code in <code>src/pycli_mcp/server.py</code> <pre><code>async def list_tools_handler(self, _: ListToolsRequest) -&gt; ServerResult:\n    \"\"\"\n    The default handler for the `ListToolsRequest`.\n    \"\"\"\n    return ServerResult(ListToolsResult(tools=self.list_command_tools()))\n</code></pre>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.call_tool_handler","title":"call_tool_handler","text":"<pre><code>call_tool_handler(req: CallToolRequest) -&gt; ServerResult\n</code></pre> <p>The default handler for the <code>CallToolRequest</code>.</p> Source code in <code>src/pycli_mcp/server.py</code> <pre><code>async def call_tool_handler(self, req: CallToolRequest) -&gt; ServerResult:\n    \"\"\"\n    The default handler for the `CallToolRequest`.\n    \"\"\"\n    command = self.commands[req.params.name].metadata.construct(req.params.arguments)\n    env_vars = dict(os.environ)\n    env_vars[\"PYCLI_MCP_TOOL_NAME\"] = req.params.name\n\n    try:\n        process = subprocess.run(  # noqa: PLW1510\n            command,\n            encoding=\"utf-8\",\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            env=env_vars,\n        )\n    # This can happen if the command is not found\n    except subprocess.CalledProcessError as e:\n        return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=str(e))], isError=True))\n\n    if process.returncode:\n        msg = f\"{process.stdout}\\nThis command exited with non-zero exit code `{process.returncode}`: {command}\"\n        return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=msg)], isError=True))\n\n    return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=process.stdout)]))\n</code></pre>"},{"location":"api/#pycli_mcp.server.CommandMCPServer.run","title":"run","text":"<pre><code>run(**kwargs: Any) -&gt; None\n</code></pre> <p>Other Parameters:</p> Name Type Description <code>**kwargs</code> <code>Any</code> <p>Additional settings to pass to the <code>uvicorn.run</code> function.</p> Source code in <code>src/pycli_mcp/server.py</code> <pre><code>def run(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Other parameters:\n        **kwargs: Additional settings to pass to the [`uvicorn.run`](https://www.uvicorn.org/#uvicornrun) function.\n    \"\"\"\n    app_settings = self.__app_settings.copy()\n    app_settings[\"routes\"] = self.routes\n    app_settings.setdefault(\"lifespan\", self.lifespan)\n    app = Starlette(**app_settings)\n    uvicorn.run(app, **kwargs)\n</code></pre>"},{"location":"api/#pycli_mcp.metadata.query.CommandQuery","title":"CommandQuery","text":"<p>A wrapper around a root command object that influences the collection behavior. Example usage:</p> <pre><code>from pycli_mcp import CommandMCPServer, CommandQuery\n\nfrom mypkg.cli import cmd\n\n# Only expose the `foo` subcommand\nquery = CommandQuery(cmd, include=r\"^foo$\")\nserver = CommandMCPServer(commands=[query])\nserver.run()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Any</code> <p>The command to inspect.</p> required <code>aggregate</code> <code>Literal['root', 'group', 'none'] | None</code> <p>The level of aggregation to use.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The expected name of the root command.</p> <code>None</code> <code>include</code> <code>str | Pattern | None</code> <p>A regular expression to include in the query.</p> <code>None</code> <code>exclude</code> <code>str | Pattern | None</code> <p>A regular expression to exclude in the query.</p> <code>None</code> <code>strict_types</code> <code>bool</code> <p>Whether to error on unknown types.</p> <code>False</code>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"<p>Added:</p> <ul> <li>Add support for Typer</li> <li>Add support for Argparse</li> <li>Always set the <code>PYCLI_MCP_TOOL_NAME</code> environment variable when running commands</li> <li>Add support for referring to a callable object that returns a command</li> </ul>"},{"location":"changelog/#020-2025-06-28","title":"0.2.0 - 2025-06-28","text":"<p>Changed:</p> <ul> <li>Rename the project to <code>pycli-mcp</code></li> <li>Rename <code>ClickCommandQuery</code> to <code>CommandQuery</code></li> <li>Rename <code>ClickMCPServer</code> to <code>CommandMCPServer</code></li> </ul>"},{"location":"changelog/#010-2025-06-26","title":"0.1.0 - 2025-06-26","text":"<p>Changed:</p> <ul> <li>The default aggregation level is now <code>root</code></li> </ul> <p>Added:</p> <ul> <li>Add support for controlling the level of command aggregation</li> <li>Increase verbosity of the CLI</li> </ul> <p>Fixed:</p> <ul> <li>Server errors now properly return the content of the command's <code>stderr</code></li> </ul>"},{"location":"changelog/#002-2025-06-24","title":"0.0.2 - 2025-06-24","text":"<p>Added:</p> <ul> <li>Add support for customizing the root command name</li> <li>Add support for more option types</li> <li>Add support for strict type checking</li> </ul> <p>Fixed:</p> <ul> <li>Fix options with dynamic default values</li> <li>The CLI now errors for specs that don't refer to a Click command object</li> </ul>"},{"location":"changelog/#001-2025-06-24","title":"0.0.1 - 2025-06-24","text":"<p>This is the initial public release.</p>"},{"location":"cli/","title":"CLI reference","text":""},{"location":"cli/#pycli-mcp","title":"pycli-mcp","text":"<p>Run an MCP server using a list of import paths to commands or callable objects that return a command:</p> <pre><code>pycli-mcp pkg1.cli:foo pkg2.cli:bar\n</code></pre> <p>Filtering is supported. For example, if you have a CLI named <code>foo</code> and you only want to expose the subcommands <code>bar</code> and <code>baz</code>, excluding the <code>baz</code> subcommands <code>sub2</code> and <code>sub3</code>, you can do:</p> <pre><code>pycli-mcp pkg.cli:foo -i \"bar|baz\" -e \"baz (sub2|sub3)\"\n</code></pre> <p>Usage:</p> <pre><code>pycli-mcp [OPTIONS] [SPECS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--aggregate</code>, <code>-a</code> choice (<code>root</code> | <code>group</code> | <code>none</code>) The level of aggregation to use, with less improving type information at the expense of more tools (default: root). Multiple specs make the format: spec=aggregation None <code>--name</code>, <code>-n</code> text The expected name of the executable, overriding the default (name of the callback). Multiple specs make the format: spec=name None <code>--include</code>, <code>-i</code> text The regular expression filter to include subcommands. Multiple specs make the format: spec=regex None <code>--exclude</code>, <code>-e</code> text The regular expression filter to exclude subcommands. Multiple specs make the format: spec=regex None <code>--strict-types</code> boolean Error on unknown types <code>False</code> <code>--debug</code> boolean Enable debug mode <code>False</code> <code>--host</code> text The host used to run the server (default: 127.0.0.1) None <code>--port</code> integer The port used to run the server (default: 8000) None <code>--log-level</code> text The log level used to run the server (default: info) None <code>--log-config</code> text The path to a file passed to the <code>logging.config.fileConfig</code> function None <code>--option</code>, <code>-o</code> Arbitrary server options (multiple allowed) e.g. -o key1 value1 -o key2 value2 None <code>--help</code>, <code>-h</code> boolean Show this message and exit. <code>False</code>"},{"location":"install/","title":"Installation","text":"<p><code>pycli-mcp</code> is available on PyPI and can be installed with a package manager like pip.</p> <pre><code>pip install pycli-mcp\n</code></pre> <p>Note</p> <p>Applications that are exposed by the server must be installed in the same environment or the <code>PYTHONPATH</code> environment variable must be set appropriately.</p>"}]}